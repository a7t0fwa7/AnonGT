from core.config.config import *
from core.config.libraries import *
from core.assets.alerts import *
from core.config.banner import logo


# check root
def check_root():
    if getuid() != 0:
        error("This script must be run as root")
        exit(0)


def check_backup_dir():
    if path.exists(BACKUPDIR) != True:
        info(f"Creating {BACKUPDIR}")
        exec_command(f"mkdir {BACKUPDIR}")


# execute command
def exec_command(cmd):
    system(cmd)


# clear terminal
def clear():
    system("clear")


# get terminal output
def get_process(cmd):
    with tempfile.TemporaryFile() as tempf:
        proc = subprocess.Popen(cmd, stdout=tempf)
        proc.wait()
        tempf.seek(0)
        result = tempf.read().decode("utf-8").strip()
        return result


# start tor service
def start_service(s):
    cmd = ["systemctl", "is-active", s]
    service = get_process(cmd)
    if service != 'active':
        warn(s + " is not active")
        exec_command(f"systemctl start {s}")
        msg(f"started {s} service")
    else:
        warn(f"{s} is active")
        exec_command(f"systemctl reload {s}")
        msg(f"reloaded {s} service")


# stop tor service
def stop_service(s):
    cmd = ["systemctl", "is-active", s]
    service = get_process(cmd)
    if service == 'active':
        warn(s + " is active")
        exec_command(f"systemctl stop {s}")
        msg(f"stopped {s} service")
    else:
        warn(f"{s} is not active")


# check if started
def is_started():
    if path.isfile(f"{BACKUPDIR}/started"):
        # Started
        return 0
    else:
        # Not Started
        return 1


# clean iptables
def flush_iptables():
    exec_command("iptables -F")
    exec_command("iptables -t nat -F")


# clean config
def wipe():
    exec_command("swapoff -a")
    exec_command("swapon -a")
    exec_command("echo 1024 > /proc/sys/vm/min_free_kbytes")
    exec_command("echo 3 > /proc/sys/vm/drop_caches")
    exec_command("echo 1 > /proc/sys/vm/oom_kill_allocating_task")
    exec_command("echo 1 > /proc/sys/vm/overcommit_memory")
    exec_command("echo 0 > /proc/sys/vm/oom_dump_tasks")
    msg("cleaned config")


# get ip
def get_ip():
    try:
        get_ip = get("https://ipinfo.io/json", verify=True)
        ip = get_ip.json()["ip"]
        msg(f"remote ip: {ip}")
    except:
        error("remote ip: unknown")


# backup torrc
def backup_torrc():
    exec_command(f"mv {TORRC} {BACKUPDIR}/torrc.bak")
    exec_command(f"chmod 644 {BACKUPDIR}/torrc.bak")
    msg("backed up tor config")


# backup resolv config
def backup_resolv_conf():
    exec_command(f"mv /etc/resolv.conf {BACKUPDIR}/resolv.conf.bak")
    exec_command(f"chmod 644 {BACKUPDIR}/resolv.conf.bak")
    msg("backed up nameservers")


# backup iptables
def backup_iptables():
    exec_command(f"iptables-save > {BACKUPDIR}/iptables.rules.bak")
    exec_command(f"chmod 644 {BACKUPDIR}/iptables.rules.bak")
    msg("backed up iptables rules")


# backup sysctl rules
def backup_sysctl():
    exec_command(f"sysctl -a > {BACKUPDIR}/sysctl.conf.bak")
    exec_command(f"chmod 644 {BACKUPDIR}/sysctl.conf.bak")
    msg("backed up sysctl rules")


# restore torrc
def restore_torrc():
    if path.isfile(BACKUPDIR + "/torrc.bak"):
        exec_command("rm -f /etc/tor/torrc")
        exec_command(f"mv {BACKUPDIR}/torrc.bak /etc/tor/torrc")
        msg("restored tor config")


# restore resolv config
def restore_resolv_conf():
    if path.isfile(BACKUPDIR + "/resolv.conf.bak"):
        exec_command(f"rm -f {BACKUPDIR}/resolv.conf")
        exec_command(f"mv {BACKUPDIR}/resolv.conf.bak /etc/resolv.conf")
        msg("restored nameservers")


# restoring iptables rules
def restore_iptables():
    if path.isfile(BACKUPDIR + "/iptables.rules.bak"):
        exec_command(f"iptables-restore <{BACKUPDIR}/iptables.rules.bak")
        exec_command(f"rm -f {BACKUPDIR}/iptables.rules.bak")
        msg("restored iptables rules")


# restore sysctl rules
def restore_sysctl():
    if path.isfile(BACKUPDIR + "/sysctl.conf.bak"):
        exec_command(f'xterm -e "sysctl -p {BACKUPDIR}/sysctl.conf.bak; exit"')
        exec_command(f"rm -f {BACKUPDIR}/sysctl.conf.bak")
        msg("restored sysctl rules")


# configure nameservers
def gen_resolv_conf():
    nameservers = ''' 
# generated by anongt
nameserver 127.0.0.1
nameserver 1.1.1.1
nameserver 1.0.0.1
nameserver 208.67.222.222
nameserver 208.67.220.220
nameserver 8.8.8.8
nameserver 8.8.4.4
'''
    exec_command(f'cat > "/etc/resolv.conf" <<EOF {nameservers}')
    exec_command("chmod 644 /etc/resolv.conf")
    msg("configured nameservers")


# configure tor
def gen_torrc():
    torconfig = f''' 
# generated by anongt
User {TOR_UID}
DataDirectory /var/lib/tor
VirtualAddrNetwork 10.192.0.0/10
AutomapHostsOnResolve 1
AutomapHostsSuffixes .exit,.onion
TransPort 127.0.0.1:{TOR_PORT} IsolateClientAddr IsolateSOCKSAuth IsolateClientProtocol IsolateDestPort IsolateDestAddr
SocksPort 127.0.0.1:9050 IsolateClientAddr IsolateSOCKSAuth IsolateClientProtocol IsolateDestPort IsolateDestAddr
ControlPort 9051
HashedControlPassword 16:FDE8ED505C45C8BA602385E2CA5B3250ED00AC0920FEC1230813A1F86F
DNSPort 127.0.0.1:{TOR_DNS}
# Sandbox 1 - tor package is not built with --enable-seccomp required to use this option.
HardwareAccel 1
TestSocks 1
AllowNonRFC953Hostnames 0
WarnPlaintextPorts 23,109,110,143,80
ClientRejectInternalAddresses 1
NewCircuitPeriod 40
MaxCircuitDirtiness 600
MaxClientCircuitsPending 48
UseEntryGuards 1
EnforceDistinctSubnets 1
'''

    exec_command(f'cat > "{TORRC}" <<EOF {torconfig}')
    exec_command(f"chmod 644 {TORRC}")
    msg("configured tor")


# get uid owner
UID_OWNER = get_process(["id", "-u", "debian-tor"])


# apply iptables rules
def apply_iptables_rules():
    # set iptables nat
    exec_command(f"iptables -t nat -A OUTPUT -m owner --uid-owner {UID_OWNER} -j RETURN")

    # set dns redirect
    exec_command(f"iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports {TOR_DNS}")
    exec_command(f"iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports {TOR_DNS}")
    exec_command(
        f"iptables -t nat -A OUTPUT -p udp -m owner --uid-owner {UID_OWNER} -m udp --dport 53 -j REDIRECT --to-ports {TOR_DNS}")

    # resolve .onion domains mapping 10.192.0.0/10 address space
    exec_command(f"iptables -t nat -A OUTPUT -p tcp -d 10.192.0.0/10 -j REDIRECT --to-ports {TOR_PORT}")
    exec_command(f"iptables -t nat -A OUTPUT -p udp -d 10.192.0.0/10 -j REDIRECT --to-ports {TOR_PORT}")

    # exlude locals
    cmd = f""" 
    for NET in {TOR_EXCLUDE} 127.0.0.0/9 127.128.0.0/10; do
        iptables -t nat -A OUTPUT -d $NET -j RETURN
        iptables -A OUTPUT -d "$NET" -j ACCEPT
    done
    """
    exec_command(cmd)
    cmd = 0

    # redirect all other output through tor
    exec_command(f"iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports {TOR_PORT}")
    exec_command(f"iptables -t nat -A OUTPUT -p udp -j REDIRECT --to-ports {TOR_PORT}")
    exec_command(f"iptables -t nat -A OUTPUT -p icmp -j REDIRECT --to-ports {TOR_PORT}")

    # accept already established connections
    exec_command("iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT")

    # allow only tor output
    exec_command(f"iptables -A OUTPUT -m owner --uid-owner {UID_OWNER} -j ACCEPT")
    exec_command("iptables -A OUTPUT -j REJECT")

    msg("applied iptables rules")


# applying sysctl rules
def apply_sysctl_rules():
    # Disable Explicit Congestion Notification in TCP
    exec_command('sysctl -w net.ipv4.tcp_ecn=0 > "/dev/null"')

    # window scaling
    exec_command('sysctl -w net.ipv4.tcp_window_scaling=1 > "/dev/null"')

    # increase linux autotuning tcp buffer limits
    exec_command('sysctl -w net.ipv4.tcp_rmem="8192 87380 16777216" > "/dev/null"')
    exec_command('sysctl -w net.ipv4.tcp_wmem="8192 65536 16777216" > "/dev/null"')

    # increase TCP max buffer size
    exec_command('sysctl -w net.core.rmem_max=16777216 > "/dev/null"')
    exec_command('sysctl -w net.core.wmem_max=16777216 > "/dev/null"')

    # Increase number of incoming connections backlog
    exec_command('sysctl -w net.core.netdev_max_backlog=16384 > "/dev/null"')
    exec_command('sysctl -w net.core.dev_weight=64 > "/dev/null"')

    # Increase number of incoming connections
    exec_command('sysctl -w net.core.somaxconn=32768 > "/dev/null"')

    # Increase the maximum amount of option memory buffers
    exec_command('sysctl -w net.core.optmem_max=65535 > "/dev/null"')

    # Increase the tcp-time-wait buckets pool size to prevent simple DOS attacks
    exec_command('sysctl -w net.ipv4.tcp_max_tw_buckets=1440000 > "/dev/null"')

    # try to reuse time-wait connections, but don't recycle them
    # (recycle can break clients behind NAT)
    exec_command('sysctl -w net.ipv4.tcp_tw_reuse=1 > "/dev/null"')

    # Limit number of orphans, each orphan can eat up to 16M (max wmem)
    # of unswappable memory
    exec_command('sysctl -w net.ipv4.tcp_max_orphans=16384 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.tcp_orphan_retries=0 > "/dev/null"')

    # don't cache ssthresh from previous connection
    exec_command('sysctl -w net.ipv4.tcp_no_metrics_save=1 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.tcp_moderate_rcvbuf=1 > "/dev/null"')

    # Increase size of RPC datagram queue length
    exec_command('sysctl -w net.unix.max_dgram_qlen=50 > "/dev/null"')

    # Don't allow the arp table to become bigger than this
    exec_command('sysctl -w net.ipv4.neigh.default.gc_thresh3=2048 > "/dev/null"')

    # Tell the gc when to become aggressive with arp table cleaning.
    # Adjust this based on size of the LAN. 1024 is suitable for most
    # /24 networks
    exec_command('sysctl -w net.ipv4.neigh.default.gc_thresh2=1024 > "/dev/null"')

    # Adjust where the gc will leave arp table alone - set to 32.
    exec_command('sysctl -w net.ipv4.neigh.default.gc_thresh1=32 > "/dev/null"')

    # Adjust to arp table gc to clean-up more often
    exec_command('sysctl -w net.ipv4.neigh.default.gc_interval=30 > "/dev/null"')

    # Increase TCP queue length
    exec_command('sysctl -w net.ipv4.neigh.default.proxy_qlen=96 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.neigh.default.unres_qlen=6 > "/dev/null"')

    # Enable Explicit Congestion Notification (RFC 3168), disable it
    # if it doesn't work for you
    exec_command('sysctl -w net.ipv4.tcp_ecn=1 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.tcp_reordering=3 > "/dev/null"')

    # How many times to retry killing an alive TCP connection
    exec_command('sysctl -w net.ipv4.tcp_retries2=15 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.tcp_retries1=3 > "/dev/null"')

    # Avoid falling back to slow start after a connection goes idle
    # keeps our cwnd large with the keep alive connections (kernel > 3.6)
    exec_command('sysctl -w net.ipv4.tcp_slow_start_after_idle=0 > "/dev/null"')

    # Allow the TCP fastopen flag to be used,
    # beware some firewalls do not like TFO! (kernel > 3.7)
    exec_command('sysctl -w net.ipv4.tcp_fastopen=3 > "/dev/null"')

    # This will enusre that immediatly subsequent connections use the new values
    exec_command('sysctl -w net.ipv4.route.flush=1 > "/dev/null"')
    exec_command('sysctl -w net.ipv6.route.flush=1 > "/dev/null"')

    # TCP SYN cookie protection
    exec_command('sysctl -w net.ipv4.tcp_syncookies=1 > "/dev/null"')

    # TCP rfc1337
    exec_command('sysctl -w net.ipv4.tcp_rfc1337=1 > "/dev/null"')

    # Reverse path filtering
    exec_command('sysctl -w net.ipv4.conf.default.rp_filter=1 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.all.rp_filter=1 > "/dev/null"')

    # Log martian packets
    exec_command('sysctl -w net.ipv4.conf.default.log_martians=1 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.all.log_martians=1 > "/dev/null"')

    # Disable ICMP redirecting
    exec_command('sysctl -w net.ipv4.conf.all.accept_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.default.accept_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.all.secure_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.default.secure_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv6.conf.all.accept_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv6.conf.default.accept_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.all.send_redirects=0 > "/dev/null"')
    exec_command('sysctl -w net.ipv4.conf.default.send_redirects=0 > "/dev/null"')

    # Enable Ignoring to ICMP Request
    exec_command('sysctl -w net.ipv4.icmp_echo_ignore_all=1 > "/dev/null"')

    # Disable IPv6
    exec_command('sysctl -w net.ipv6.conf.all.disable_ipv6=1 > "/dev/null"')
    exec_command('sysctl -w net.ipv6.conf.default.disable_ipv6=1 > "/dev/null"')

    msg("applied sysctl rules")


def firefox():
    if path.isdir("/etc/firefox-esr") == True or path.isdir("/etc/firefox") == True:
        exec_command(f"su {getlogin()} -c 'firefox https://check.torproject.org/ &'")


# Function to convert
def listToString(s):
    # initialize an empty string
    str1 = " "

    # return string
    return (str1.join(s))
